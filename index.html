<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢å¼·ç‰ˆå‹•æ…‹ç‰¹æ•ˆè¦†è“‹å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-area {
            border: 3px dashed rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }

        .upload-area:hover {
            border-color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.15);
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            min-width: 200px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 16px;
        }

        select {
            cursor: pointer;
        }

        select option {
            background: #2a5298;
            color: white;
        }

        input[type="range"] {
            padding: 5px;
            background: rgba(255,255,255,0.1);
        }

        .media-container {
            position: relative;
            max-width: 100%;
            margin: 0 auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
            width: 300px;
            height: 300px;
        }

        #mediaElement {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #effectCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        .download-section {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .download-options {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .option-group {
            margin: 15px 0;
            text-align: left;
        }

        .option-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .download-btn {
            background: linear-gradient(45deg, #FF6B6B, #ee5a52);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .download-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }

        .effect-info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .effect-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .category-section {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }

        .category-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .download-btn {
                display: block;
                margin: 10px auto;
                width: 80%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒŸ å¢å¼·ç‰ˆå‹•æ…‹ç‰¹æ•ˆè¦†è“‹å™¨ âœ¨</h1>
        
        <div class="upload-area" id="uploadArea">
            <p style="font-size: 1.2em; margin-bottom: 20px;">æ‹–æ›³ç…§ç‰‡æˆ–å½±ç‰‡åˆ°é€™è£¡ï¼Œæˆ–é»æ“Šä¸Šå‚³</p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                ğŸ“ é¸æ“‡æª”æ¡ˆ
            </button>
            <input type="file" id="fileInput" accept="image/*,video/*">
            <div id="ffmpegStatus" style="margin-top:10px;font-size:12px;opacity:0.85"></div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="effectType">ç‰¹æ•ˆé¡å‹</label>
                <select id="effectType">
                    <optgroup label="å¤©æ°£æ•ˆæœ">
                        <option value="snow">â„ï¸ ä¸‹é›ª</option>
                        <option value="rain">ğŸŒ§ï¸ ä¸‹é›¨</option>
                        <option value="storm">â›ˆï¸ æš´é¢¨é›¨</option>
                        <option value="lightning">âš¡ é–ƒé›»</option>
                    </optgroup>
                    <optgroup label="è‡ªç„¶æ•ˆæœ">
                        <option value="leaves">ğŸ‚ è½è‘‰</option>
                        <option value="sakura">ğŸŒ¸ æ«»èŠ±</option>
                        <option value="fireflies">âœ¨ è¢ç«èŸ²</option>
                        <option value="butterflies">ğŸ¦‹ è´è¶</option>
                    </optgroup>
                    <optgroup label="å¤¢å¹»æ•ˆæœ">
                        <option value="stars">â­ æ˜Ÿæ˜Ÿ</option>
                        <option value="bubbles">ğŸ«§ æ³¡æ³¡</option>
                        <option value="hearts">ğŸ’– æ„›å¿ƒ</option>
                        <option value="sparkles">âœ¨ é–ƒçˆ</option>
                    </optgroup>
                    <optgroup label="ç§‘æŠ€æ•ˆæœ">
                        <option value="matrix">ğŸ”¢ æ•¸å­—é›¨</option>
                        <option value="particles">âš›ï¸ ç²’å­æµ</option>
                        <option value="glitch">ğŸ“º æ•…éšœæ•ˆæœ</option>
                        <option value="neon">ğŸ’ éœ“è™¹</option>
                    </optgroup>
                    <optgroup label="é­”æ³•æ•ˆæœ">
                        <option value="magic">ğŸª„ é­”æ³•ç²’å­</option>
                        <option value="fairy">ğŸ§š ä»™å¥³å¡µ</option>
                        <option value="portal">ğŸŒ€ å‚³é€é–€</option>
                        <option value="runes">ğŸ”® ç¬¦æ–‡</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="control-group">
                <label for="intensity">å¼·åº¦: <span id="intensityValue">50</span></label>
                <input type="range" id="intensity" min="10" max="200" value="50">
            </div>
            
            <div class="control-group">
                <label for="speed">é€Ÿåº¦: <span id="speedValue">2</span></label>
                <input type="range" id="speed" min="0.5" max="5" step="0.1" value="2">
            </div>
            
            <div class="control-group">
                <label for="size">å¤§å°: <span id="sizeValue">3</span></label>
                <input type="range" id="size" min="1" max="8" step="0.5" value="3">
            </div>

            <div class="control-group">
                <label for="colorMode">é¡è‰²æ¨¡å¼</label>
                <select id="colorMode">
                    <option value="default">é è¨­</option>
                    <option value="rainbow">å½©è™¹</option>
                    <option value="monochrome">å–®è‰²</option>
                    <option value="warm">æš–è‰²èª¿</option>
                    <option value="cool">å†·è‰²èª¿</option>
                </select>
            </div>

            <div class="control-group">
                <label for="blendMode">æ··åˆæ¨¡å¼</label>
                <select id="blendMode">
                    <option value="normal">æ­£å¸¸</option>
                    <option value="multiply">ç›¸ä¹˜</option>
                    <option value="screen">æ¿¾è‰²</option>
                    <option value="overlay">è¦†è“‹</option>
                    <option value="soft-light">æŸ”å…‰</option>
                    <option value="hard-light">å¼·å…‰</option>
                    <option value="difference">å·®ç•°</option>
                    <option value="exclusion">æ’é™¤</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>å¿«é€Ÿè¨­å®š</label>
                <button class="upload-btn" id="lowLoadBtn">âš™ï¸ ä½è² è¼‰æ¨¡å¼</button>
            </div>
        </div>

        <div class="media-container" id="mediaContainer">
            <img id="mediaElement" style="display: none;">
            <video id="videoElement" style="display: none;" controls muted loop></video>
            <canvas id="effectCanvas"></canvas>
        </div>

        <div class="download-section" id="downloadSection">
            <div class="download-options">
                <h3 style="text-align: center; margin-bottom: 20px;">ğŸ’¾ ä¸‹è¼‰é¸é …</h3>
                
                <div class="option-group">
                    <label for="duration">å‹•ç•«æ™‚é•·: <span id="durationValue">5</span> ç§’</label>
                    <input type="range" id="duration" min="3" max="15" value="5" style="width: 100%;">
                </div>
                
                <div class="option-group">
                    <label for="fps">å¹€ç‡ (FPS)</label>
                    <select id="fps" style="width: 100%;">
                        <option value="15">15 FPS (æª”æ¡ˆè¼ƒå°)</option>
                        <option value="24" selected>24 FPS (æ¨™æº–)</option>
                        <option value="30">30 FPS (æµæš¢)</option>
                        <option value="60">60 FPS (è¶…æµæš¢)</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="quality">å“è³ªè¨­å®š</label>
                    <select id="quality" style="width: 100%;">
                        <option value="0.3">ä½å“è³ª (æª”æ¡ˆæœ€å°)</option>
                        <option value="0.6">ä¸­å“è³ª</option>
                        <option value="0.8" selected>é«˜å“è³ª</option>
                        <option value="1.0">æœ€é«˜å“è³ª</option>
                    </select>
                </div>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText" style="text-align: center; margin: 10px 0;"></div>
                
                <div style="text-align: center;">
                    <button class="download-btn" id="downloadGifBtn">ğŸï¸ ä¸‹è¼‰ GIF å‹•ç•«</button>
                    <button class="download-btn" id="downloadMp4Btn">ğŸ¬ ä¸‹è¼‰ WebM å½±ç‰‡</button>
                    <button class="download-btn" id="downloadImageBtn">ğŸ–¼ï¸ ä¸‹è¼‰éœæ…‹åœ–ç‰‡</button>
                    
                </div>
            </div>
        </div>

       

    <script src="gif.js"></script>
    <!-- ffmpeg.wasm via CDN -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>
    <script>
        // å¼·åˆ¶æ‰€æœ‰ 2D context ä½¿ç”¨ willReadFrequentlyï¼ŒåŒ…å« gif.js å…§éƒ¨å»ºç«‹çš„ canvas
        (function() {
            const originalGetContext = HTMLCanvasElement.prototype.getContext;
            HTMLCanvasElement.prototype.getContext = function(type, options) {
                if (type === '2d') {
                    const nextOptions = options && typeof options === 'object' ? {...options} : {};
                    if (!nextOptions.willReadFrequently) nextOptions.willReadFrequently = true;
                    return originalGetContext.call(this, type, nextOptions);
                }
                return originalGetContext.call(this, type, options);
            };
        })();
    </script>
    <script>
        class EnhancedEffectEngine {
            constructor() {
                this.canvas = document.getElementById('effectCanvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.particles = [];
                this.animationId = null;
                this.effectType = 'snow';
                this.intensity = 50;
                this.speed = 2;
                this.size = 3;
                this.colorMode = 'default';
                this.blendMode = 'normal';
                this.isImage = true;
                this.mediaElement = null;
                this.time = 0;
                
                // ç‰¹æ•ˆç›¸é—œå±¬æ€§
                this.lightningFlashes = [];
                this.magicTrails = [];
                this.runeRotations = [];
                
                // ffmpeg core base URLï¼ˆæœƒåœ¨è¼‰å…¥æ™‚å‹•æ…‹æ±ºå®šï¼‰
                this.ffmpegCoreBase = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js';

                this.setupEventListeners();
            }
            
            async loadFFmpegScript() {
                if (window.FFmpeg || window.createFFmpeg) return;
                // å…è¨±æ‰‹å‹•æŒ‡å®šï¼ˆä¾‹å¦‚åœ¨ GitHub Pages å­è·¯å¾‘ï¼‰
                const manualScript = (window.FFMPEG_SCRIPT_URL || (window.FFMPEG_BASE_URL && window.FFMPEG_BASE_URL + '/ffmpeg.min.js')) || null;
                const manualCore = (window.FFMPEG_CORE_URL || (window.FFMPEG_BASE_URL && window.FFMPEG_BASE_URL + '/ffmpeg-core.js')) || null;

                // å¾ç›®å‰ç¶²å€è‡ªå‹•æ¨æ¸¬ GitHub Pages å­è·¯å¾‘ï¼Œä¾‹å¦‚ /effect002/
                let inferredBase = '';
                try {
                    const parts = (location.pathname || '').split('/').filter(Boolean);
                    if (parts.length >= 1) {
                        inferredBase = `/${parts[0]}`; // ä¾‹å¦‚ /effect002
                    }
                } catch(_) {}

                const candidates = [
                    // ä½¿ç”¨è€…è‡ªè¨‚å„ªå…ˆ
                    ...(manualScript ? [{ script: manualScript, core: manualCore || manualScript.replace('ffmpeg.min.js', 'ffmpeg-core.js') }] : []),
                    {
                        script: 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js',
                        core: 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js'
                    },
                    {
                        script: 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js',
                        core: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js'
                    },
                    {
                        script: 'https://esm.run/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js',
                        core: 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js'
                    },
                    // æœ¬æ©Ÿç›¸å°è·¯å¾‘ï¼ˆé é¢åœ¨å­è³‡æ–™å¤¾æ™‚å˜—è©¦å¤šå±¤ï¼‰
                    { script: './libs/ffmpeg/ffmpeg.min.js', core: './libs/ffmpeg/ffmpeg-core.js' },
                    { script: 'libs/ffmpeg/ffmpeg.min.js', core: 'libs/ffmpeg/ffmpeg-core.js' },
                    { script: '../libs/ffmpeg/ffmpeg.min.js', core: '../libs/ffmpeg/ffmpeg-core.js' },
                    { script: '../../libs/ffmpeg/ffmpeg.min.js', core: '../../libs/ffmpeg/ffmpeg-core.js' },
                    // ç«™å°æ ¹ç›®éŒ„ï¼ˆæœ¬æ©Ÿé–‹ç™¼å¯ç”¨ï¼›GitHub Pages è‹¥æœ‰å°ˆæ¡ˆå­è·¯å¾‘å‰‡å¯èƒ½ç„¡æ•ˆï¼‰
                    { script: '/libs/ffmpeg/ffmpeg.min.js', core: '/libs/ffmpeg/ffmpeg-core.js' },
                    // GitHub Pages å°ˆæ¡ˆå­è·¯å¾‘ï¼ˆè‡ªå‹•æ¨æ¸¬ï¼‰
                    ...(inferredBase ? [{ script: `${inferredBase}/libs/ffmpeg/ffmpeg.min.js`, core: `${inferredBase}/libs/ffmpeg/ffmpeg-core.js` }] : [])
                ];
                const tryLoad = (src) => new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = () => resolve(true);
                    s.onerror = () => reject(new Error('Failed to load ' + src));
                    document.head.appendChild(s);
                });
                let lastError = null;
                for (const c of candidates) {
                    try {
                        await tryLoad(c.script);
                        this.ffmpegCoreBase = c.core;
                        this.updateFfmpegStatus(`FFmpeg ä¾†æºï¼š${c.script}`);
                        return;
                    } catch (e) {
                        lastError = e;
                        this.updateFfmpegStatus(`è¼‰å…¥å¤±æ•—ï¼š${c.script}`);
                    }
                }
                throw lastError || new Error('Failed to load ffmpeg script');
            }

            async ensureFFmpeg() {
                if (this.ffmpeg && this.ffmpeg.isLoaded) return;
                if (!window.FFmpeg && !window.createFFmpeg) {
                    await this.loadFFmpegScript();
                }
                const createFFmpeg = (window.FFmpeg && window.FFmpeg.createFFmpeg) || window.createFFmpeg;
                if (!createFFmpeg) throw new Error('FFmpeg library not loaded');
                this.ffmpeg = createFFmpeg({
                    log: false,
                    corePath: this.ffmpegCoreBase
                });
                try {
                    await this.ffmpeg.load();
                    this.updateFfmpegStatus(`FFmpeg core OKï¼š${this.ffmpegCoreBase}`);
                } catch (e) {
                    this.updateFfmpegStatus(`FFmpeg core è¼‰å…¥å¤±æ•—ï¼š${this.ffmpegCoreBase}`);
                    throw e;
                }
            }

            updateFfmpegStatus(text) {
                const el = document.getElementById('ffmpegStatus');
                if (!el) return;
                const now = new Date();
                const time = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
                const line = document.createElement('div');
                line.textContent = `[${time}] ${text}`;
                el.appendChild(line);
            }
            
            async convertWebmToMp4(webmBlob) {
                await this.ensureFFmpeg();
                const data = new Uint8Array(await webmBlob.arrayBuffer());
                // å¯«å…¥è¼¸å…¥æª”
                try { this.ffmpeg.FS('unlink', 'input.webm'); } catch(_) {}
                try { this.ffmpeg.FS('unlink', 'output.mp4'); } catch(_) {}
                this.ffmpeg.FS('writeFile', 'input.webm', data);
                // è½‰æª”ï¼šH.264 + yuv420p + faststart
                await this.ffmpeg.run(
                    '-i', 'input.webm',
                    '-c:v', 'libx264',
                    '-pix_fmt', 'yuv420p',
                    '-movflags', 'faststart',
                    '-an',
                    'output.mp4'
                );
                const out = this.ffmpeg.FS('readFile', 'output.mp4');
                return new Blob([out.buffer], { type: 'video/mp4' });
            }

            async convertGifToWebm(gifBlob) {
                await this.ensureFFmpeg();
                const data = new Uint8Array(await gifBlob.arrayBuffer());
                try { this.ffmpeg.FS('unlink', 'input.gif'); } catch(_) {}
                try { this.ffmpeg.FS('unlink', 'output.webm'); } catch(_) {}
                this.ffmpeg.FS('writeFile', 'input.gif', data);
                // å°‡ GIF è½‰ç‚º WebMï¼ˆè¼ƒå¯¬é¬†ã€é€Ÿåº¦å„ªå…ˆï¼‰ï¼šVP8 + realtimeï¼Œå¿…è¦æ™‚å¯ç¸®æ”¾/é™ FPS
                // è‡ªå‹•åµæ¸¬å¹€ç‡èˆ‡å°ºå¯¸ï¼›å¦‚éœ€é™åˆ¶ï¼Œå¯åœ¨æ­¤åŠ å…¥ -vf scale=... æˆ– -r ...
                await this.ffmpeg.run(
                    '-i', 'input.gif',
                    '-c:v', 'libvpx',
                    '-b:v', '1.5M',
                    '-deadline', 'realtime',
                    '-pix_fmt', 'yuv420p',
                    '-an',
                    'output.webm'
                );
                const out = this.ffmpeg.FS('readFile', 'output.webm');
                return new Blob([out.buffer], { type: 'video/webm' });
            }
            
            setupEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                const effectType = document.getElementById('effectType');
                const intensity = document.getElementById('intensity');
                const speed = document.getElementById('speed');
                const size = document.getElementById('size');
                const colorMode = document.getElementById('colorMode');
                const blendMode = document.getElementById('blendMode');
                const downloadGifBtn = document.getElementById('downloadGifBtn');
                const downloadMp4Btn = document.getElementById('downloadMp4Btn');
                const downloadImageBtn = document.getElementById('downloadImageBtn');
                const convertMp4Btn = document.getElementById('convertMp4Btn');
                const duration = document.getElementById('duration');
                const lowLoadBtn = document.getElementById('lowLoadBtn');
                
                // File upload
                fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFile(e.dataTransfer.files[0]);
                });
                
                // Controls
                effectType.addEventListener('change', (e) => {
                    this.effectType = e.target.value;
                    this.initParticles();
                });
                
                intensity.addEventListener('input', (e) => {
                    this.intensity = parseInt(e.target.value);
                    document.getElementById('intensityValue').textContent = e.target.value;
                    this.initParticles();
                });
                
                speed.addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = e.target.value;
                });
                
                size.addEventListener('input', (e) => {
                    this.size = parseFloat(e.target.value);
                    document.getElementById('sizeValue').textContent = e.target.value;
                });
                
                colorMode.addEventListener('change', (e) => {
                    this.colorMode = e.target.value;
                });
                
                blendMode.addEventListener('change', (e) => {
                    this.blendMode = e.target.value;
                });
                
                duration.addEventListener('input', (e) => {
                    document.getElementById('durationValue').textContent = e.target.value;
                });
                
                // Download buttons
                downloadGifBtn.addEventListener('click', () => this.downloadGif());
                downloadMp4Btn.addEventListener('click', () => this.downloadMp4());
                downloadImageBtn.addEventListener('click', () => this.downloadImage());
                
                if (convertMp4Btn) {
                    convertMp4Btn.addEventListener('click', async () => {
                        try {
                            const picker = document.createElement('input');
                            picker.type = 'file';
                            picker.accept = 'video/webm';
                            picker.onchange = async () => {
                                const file = picker.files && picker.files[0];
                                if (!file) return;
                                this.setButtonsState(true);
                                this.showProgress('æ­£åœ¨è½‰æª”ç‚º MP4 (ç€è¦½å™¨ç«¯è½‰æª”)...');
                                try {
                                    const mp4Blob = await this.convertWebmToMp4(file);
                                    const url = URL.createObjectURL(mp4Blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = `convert_${Date.now()}.mp4`;
                                    a.click();
                                    URL.revokeObjectURL(url);
                                } catch (e) {
                                    console.error('è½‰æª” MP4 å¤±æ•—ï¼š', e);
                                    alert('è½‰æª” MP4 å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæˆ–é™ä½å¤§å°å¾Œé‡è©¦');
                                } finally {
                                    this.hideProgress();
                                    this.setButtonsState(false);
                                }
                            };
                            picker.click();
                        } catch (e) {
                            console.error(e);
                            alert('è½‰æª”å™¨åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹ç¨å¾Œé‡è©¦');
                        }
                    });
                }

                // å¿«é€Ÿä½è² è¼‰è¨­å®š
                if (lowLoadBtn) {
                    lowLoadBtn.addEventListener('click', () => {
                        // åŸºæœ¬ç•«é¢åƒæ•¸
                        intensity.value = 30; this.intensity = 30; document.getElementById('intensityValue').textContent = '30';
                        size.value = 3; this.size = 3; document.getElementById('sizeValue').textContent = '3';
                        speed.value = 2; this.speed = 2; document.getElementById('speedValue').textContent = '2';
                        colorMode.value = 'default'; this.colorMode = 'default';
                        blendMode.value = 'normal'; this.blendMode = 'normal';
                        
                        // ä¸‹è¼‰åƒæ•¸
                        const fpsSel = document.getElementById('fps'); if (fpsSel) fpsSel.value = '15';
                        duration.value = 3; document.getElementById('durationValue').textContent = '3';
                        const qualitySel = document.getElementById('quality'); if (qualitySel) qualitySel.value = '0.6';
                        
                        // é‡æ–°ç”¢ç”Ÿç²’å­
                        this.initParticles();
                    });
                }
            }
            
            async handleFile(file) {
                if (!file) return;
                
                const mediaContainer = document.getElementById('mediaContainer');
                const imgElement = document.getElementById('mediaElement');
                const videoElement = document.getElementById('videoElement');
                const downloadSection = document.getElementById('downloadSection');
                
                downloadSection.style.display = 'block';

                // å‹•æ…‹ GIFï¼šå…ˆè½‰ç‚º WebMï¼Œå†èµ°å½±ç‰‡æµç¨‹ï¼Œä¿ç•™åŸæœ¬å‹•æ…‹
                if (file.type === 'image/gif') {
                    try {
                        this.setButtonsState(true);
                        this.showProgress('æ­£åœ¨å°‡ GIF è½‰ç‚ºå½±ç‰‡ä»¥ä¿ç•™å‹•æ…‹...');
                        const webmBlob = await this.convertGifToWebm(file);
                        const url = URL.createObjectURL(webmBlob);
                        this.isImage = false;
                        this.mediaElement = videoElement;
                        videoElement.src = url;
                        videoElement.style.display = 'block';
                        imgElement.style.display = 'none';
                        videoElement.onloadedmetadata = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                            videoElement.play();
                            // ä¿ç•™ URL è‡³å°‘åˆ°é›¢é–‹é é¢ï¼›å¦‚éœ€é‡‹æ”¾å¯åœ¨åˆ‡æ›æª”æ¡ˆæ™‚ revoke
                        };
                    } catch (e) {
                        console.error('GIF è½‰ WebM å¤±æ•—ï¼š', e);
                        alert('GIF è½‰æ›å¤±æ•—ï¼Œå°‡ä»¥éœæ…‹åœ–ç‰‡é¡¯ç¤ºã€‚å¯å˜—è©¦ä½è² è¼‰æ¨¡å¼æˆ–æ”¹å‚³å½±ç‰‡ã€‚');
                        // è½‰æ›å¤±æ•—å‰‡é€€å›åŸæœ¬åœ–ç‰‡æµç¨‹ï¼ˆæœƒæ˜¯éœæ…‹ï¼‰
                    } finally {
                        this.hideProgress();
                        this.setButtonsState(false);
                    }
                    mediaContainer.style.display = 'block';
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.type.startsWith('image/')) {
                        this.isImage = true;
                        this.mediaElement = imgElement;
                        imgElement.src = e.target.result;
                        imgElement.style.display = 'block';
                        videoElement.style.display = 'none';
                        videoElement.pause();
                        
                        imgElement.onload = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                        };
                    } else if (file.type.startsWith('video/')) {
                        this.isImage = false;
                        this.mediaElement = videoElement;
                        videoElement.src = e.target.result;
                        videoElement.style.display = 'block';
                        imgElement.style.display = 'none';
                        
                        videoElement.onloadedmetadata = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                            videoElement.play();
                        };
                    }
                };
                reader.readAsDataURL(file);
                mediaContainer.style.display = 'block';
            }
            
            setupCanvas() {
                this.mediaElement = this.isImage ? 
                    document.getElementById('mediaElement') : 
                    document.getElementById('videoElement');
                
                const container = document.getElementById('mediaContainer');
                const targetWidth = (container && container.clientWidth) || this.mediaElement.offsetWidth || 300;
                const targetHeight = (container && container.clientHeight) || this.mediaElement.offsetHeight || 300;
                
                this.canvas.width = targetWidth;
                this.canvas.height = targetHeight;
            }
            
            getParticleColor(particle, baseColor = null) {
                const { colorMode } = this;
                let color = baseColor || 'white';
                
                switch (colorMode) {
                    case 'rainbow':
                        const hue = (particle.hue || 0) + this.time * 0.5;
                        color = `hsl(${hue % 360}, 70%, 60%)`;
                        break;
                    case 'monochrome':
                        const gray = Math.random() * 100 + 50;
                        color = `hsl(0, 0%, ${gray}%)`;
                        break;
                    case 'warm':
                        const warmHue = Math.random() * 60 + 300; // ç´…-æ©™-é»ƒ
                        color = `hsl(${warmHue}, 70%, 60%)`;
                        break;
                    case 'cool':
                        const coolHue = Math.random() * 120 + 180; // è—-ç¶ -é’
                        color = `hsl(${coolHue}, 70%, 60%)`;
                        break;
                }
                
                return color;
            }
            
            initParticles() {
                this.particles = [];
                this.lightningFlashes = [];
                this.magicTrails = [];
                this.runeRotations = [];
                
                for (let i = 0; i < this.intensity; i++) {
                    this.particles.push(this.createParticle());
                }
                
                // åˆå§‹åŒ–ç¬¦æ–‡æ—‹è½‰è§’åº¦
                if (this.effectType === 'runes') {
                    for (let i = 0; i < this.intensity; i++) {
                        this.runeRotations.push(Math.random() * Math.PI * 2);
                    }
                }
            }
            
            createParticle() {
                const particle = {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height - this.canvas.height,
                    vx: 0,
                    vy: 0,
                    size: Math.random() * this.size + 1,
                    opacity: Math.random() * 0.8 + 0.2,
                    angle: 0,
                    hue: Math.random() * 360,
                    life: 1,
                    maxLife: 1,
                    trail: []
                };
                
                switch (this.effectType) {
                    case 'snow':
                        particle.vx = (Math.random() - 0.5) * 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        break;
                    case 'rain':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 3;
                        particle.size = Math.random() * 2 + 1;
                        break;
                    case 'storm':
                        particle.vx = Math.random() * 4 - 2;
                        particle.vy = Math.random() * this.speed + 5;
                        particle.size = Math.random() * 3 + 1;
                        break;
                    case 'lightning':
                        particle.vx = 0;
                        particle.vy = 0;
                        particle.life = Math.random() * 0.3 + 0.1;
                        particle.maxLife = particle.life;
                        break;
                    case 'leaves':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 1;
                        particle.angle = Math.random() * Math.PI * 2;
                        break;
                    case 'sakura':
                        particle.vx = Math.random() * 1 - 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.angle = Math.random() * Math.PI * 2;
                        break;
                    case 'fireflies':
                        particle.vx = (Math.random() - 0.5) * 2;
                        particle.vy = (Math.random() - 0.5) * 2;
                        particle.glowIntensity = Math.random();
                        break;
                    case 'butterflies':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.wingPhase = Math.random() * Math.PI * 2;
                        break;
                    case 'stars':
                        particle.vx = (Math.random() - 0.5) * 0.2;
                        particle.vy = Math.random() * this.speed * 0.5 + 0.2;
                        particle.twinkle = Math.random() * Math.PI * 2;
                        break;
                    case 'bubbles':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = -Math.random() * this.speed - 0.5;
                        particle.size = Math.random() * this.size + 2;
                        break;
                    case 'hearts':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.pulse = Math.random() * Math.PI * 2;
                        break;
                    case 'sparkles':
                        particle.vx = (Math.random() - 0.5) * 2;
                        particle.vy = (Math.random() - 0.5) * 2;
                        particle.sparklePhase = Math.random() * Math.PI * 2;
                        break;
                    case 'matrix':
                        particle.vx = 0;
                        particle.vy = Math.random() * this.speed + 2;
                        particle.char = String.fromCharCode(0x30A0 + Math.random() * 96);
                        break;
                    case 'particles':
                        const angle = Math.random() * Math.PI * 2;
                        particle.vx = Math.cos(angle) * this.speed;
                        particle.vy = Math.sin(angle) * this.speed;
                        break;
                    case 'glitch':
                        particle.vx = (Math.random() - 0.5) * 10;
                        particle.vy = (Math.random() - 0.5) * 10;
                        particle.life = Math.random() * 0.2 + 0.1;
                        particle.maxLife = particle.life;
                        break;
                    case 'neon':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = Math.random() * this.speed + 1;
                        particle.glowSize = Math.random() * 10 + 5;
                        break;
                    case 'magic':
                        particle.vx = (Math.random() - 0.5) * 3;
                        particle.vy = (Math.random() - 0.5) * 3;
                        particle.trail = [];
                        break;
                    case 'fairy':
                        particle.vx = (Math.random() - 0.5) * 2;
                        particle.vy = -Math.random() * this.speed - 0.5;
                        particle.shimmer = Math.random() * Math.PI * 2;
                        break;
                    case 'portal':
                        const radius = Math.random() * 100 + 50;
                        const portalAngle = Math.random() * Math.PI * 2;
                        particle.x = this.canvas.width / 2 + Math.cos(portalAngle) * radius;
                        particle.y = this.canvas.height / 2 + Math.sin(portalAngle) * radius;
                        particle.vx = -Math.cos(portalAngle) * this.speed;
                        particle.vy = -Math.sin(portalAngle) * this.speed;
                        break;
                    case 'runes':
                        particle.vx = (Math.random() - 0.5) * 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.runeType = Math.floor(Math.random() * 6);
                        break;
                }
                
                return particle;
            }
            
            updateParticle(particle, index) {
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // ç‰¹æ•ˆç‰¹æ®Šæ›´æ–°é‚è¼¯
                switch (this.effectType) {
                    case 'leaves':
                    case 'sakura':
                        particle.angle += 0.02;
                        particle.x += Math.sin(particle.angle) * 0.5;
                        break;
                    case 'fireflies':
                        particle.vx += (Math.random() - 0.5) * 0.1;
                        particle.vy += (Math.random() - 0.5) * 0.1;
                        particle.glowIntensity = Math.sin(this.time * 0.1 + index) * 0.5 + 0.5;
                        break;
                    case 'butterflies':
                        particle.wingPhase += 0.3;
                        particle.vy += Math.sin(particle.wingPhase) * 0.1;
                        break;
                    case 'stars':
                        particle.twinkle += 0.1;
                        break;
                    case 'hearts':
                        particle.pulse += 0.1;
                        break;
                    case 'sparkles':
                        particle.sparklePhase += 0.2;
                        break;
                    case 'lightning':
                        particle.life -= 0.02;
                        if (particle.life <= 0) {
                            particle.life = Math.random() * 0.3 + 0.1;
                            particle.maxLife = particle.life;
                            particle.x = Math.random() * this.canvas.width;
                            particle.y = Math.random() * this.canvas.height;
                        }
                        break;
                    case 'particles':
                        particle.life -= 0.01;
                        if (particle.life <= 0) {
                            particle.life = 1;
                            particle.x = this.canvas.width / 2;
                            particle.y = this.canvas.height / 2;
                            const angle = Math.random() * Math.PI * 2;
                            particle.vx = Math.cos(angle) * this.speed;
                            particle.vy = Math.sin(angle) * this.speed;
                        }
                        break;
                    case 'glitch':
                        particle.life -= 0.05;
                        if (particle.life <= 0) {
                            particle.life = Math.random() * 0.2 + 0.1;
                            particle.maxLife = particle.life;
                            particle.x = Math.random() * this.canvas.width;
                            particle.y = Math.random() * this.canvas.height;
                        }
                        break;
                    case 'magic':
                        particle.trail.push({x: particle.x, y: particle.y, life: 1});
                        particle.trail = particle.trail.filter(t => t.life > 0);
                        particle.trail.forEach(t => t.life -= 0.05);
                        
                        particle.vx += (Math.random() - 0.5) * 0.2;
                        particle.vy += (Math.random() - 0.5) * 0.2;
                        break;
                    case 'fairy':
                        particle.shimmer += 0.15;
                        break;
                    case 'portal':
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        const dx = centerX - particle.x;
                        const dy = centerY - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 20) {
                            // é‡æ–°ç”Ÿæˆåœ¨å¤–åœ
                            const radius = Math.random() * 100 + 50;
                            const angle = Math.random() * Math.PI * 2;
                            particle.x = centerX + Math.cos(angle) * radius;
                            particle.y = centerY + Math.sin(angle) * radius;
                            particle.vx = -Math.cos(angle) * this.speed;
                            particle.vy = -Math.sin(angle) * this.speed;
                        }
                        break;
                    case 'runes':
                        if (this.runeRotations[index] !== undefined) {
                            this.runeRotations[index] += 0.02;
                        }
                        break;
                }
                
                // é‡ç½®è¶…å‡ºé‚Šç•Œçš„ç²’å­
                if (this.needsReset(particle)) {
                    this.resetParticle(particle);
                }
            }
            
            needsReset(particle) {
                switch (this.effectType) {
                    case 'bubbles':
                        return particle.y < -particle.size;
                    case 'lightning':
                    case 'glitch':
                    case 'particles':
                        return false; // é€™äº›æ•ˆæœæœ‰è‡ªå·±çš„ç”Ÿå‘½é€±æœŸ
                    case 'portal':
                        return false; // å‚³é€é–€æ•ˆæœæœ‰ç‰¹æ®Šé‚è¼¯
                    default:
                        return particle.y > this.canvas.height + particle.size || 
                               particle.x < -particle.size || 
                               particle.x > this.canvas.width + particle.size;
                }
            }
            
            resetParticle(particle) {
                switch (this.effectType) {
                    case 'bubbles':
                        particle.y = this.canvas.height + particle.size;
                        particle.x = Math.random() * this.canvas.width;
                        particle.vy = -Math.random() * this.speed - 0.5;
                        break;
                    default:
                        particle.y = -particle.size;
                        particle.x = Math.random() * this.canvas.width;
                        if (this.effectType === 'storm') {
                            particle.vx = Math.random() * 4 - 2;
                        }
                        break;
                }
            }
            
            drawParticle(particle, index) {
                this.ctx.save();
                this.ctx.globalCompositeOperation = this.blendMode;
                this.ctx.globalAlpha = particle.opacity;
                
                switch (this.effectType) {
                    case 'snow':
                        this.ctx.fillStyle = this.getParticleColor(particle, 'white');
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'rain':
                    case 'storm':
                        this.ctx.strokeStyle = this.getParticleColor(particle, 'rgba(174, 194, 224, 0.8)');
                        this.ctx.lineWidth = particle.size;
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.x, particle.y);
                        this.ctx.lineTo(particle.x + particle.vx * 5, particle.y + particle.vy * 5);
                        this.ctx.stroke();
                        break;
                        
                    case 'lightning':
                        if (Math.random() < 0.1) { // é–ƒé›»å‡ºç¾æ©Ÿç‡
                            this.drawLightning();
                        }
                        break;
                        
                    case 'leaves':
                        this.ctx.translate(particle.x, particle.y);
                        this.ctx.rotate(particle.angle);
                        this.ctx.fillStyle = this.getParticleColor(particle, `hsl(${30 + Math.random() * 60}, 70%, 50%)`);
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, particle.size, particle.size * 0.6, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'sakura':
                        this.drawSakuraPetal(particle);
                        break;
                        
                    case 'fireflies':
                        const glowSize = particle.size * (2 + particle.glowIntensity * 2);
                        const gradient = this.ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, glowSize);
                        gradient.addColorStop(0, this.getParticleColor(particle, 'rgba(255, 255, 100, 0.8)'));
                        gradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, glowSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'butterflies':
                        this.drawButterfly(particle);
                        break;
                        
                    case 'stars':
                        const twinkleOpacity = Math.sin(particle.twinkle) * 0.5 + 0.5;
                        this.ctx.globalAlpha *= twinkleOpacity;
                        this.ctx.fillStyle = this.getParticleColor(particle, 'gold');
                        this.drawStar(particle.x, particle.y, 5, particle.size, particle.size * 0.5);
                        break;
                        
                    case 'bubbles':
                        const bubbleGradient = this.ctx.createRadialGradient(
                            particle.x - particle.size * 0.3, particle.y - particle.size * 0.3, 0,
                            particle.x, particle.y, particle.size
                        );
                        bubbleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        bubbleGradient.addColorStop(0.7, this.getParticleColor(particle, 'rgba(173, 216, 230, 0.4)'));
                        bubbleGradient.addColorStop(1, 'rgba(173, 216, 230, 0.1)');
                        
                        this.ctx.fillStyle = bubbleGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.strokeStyle = this.getParticleColor(particle, 'rgba(173, 216, 230, 0.6)');
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                        break;
                        
                    case 'hearts':
                        const pulseSize = particle.size * (1 + Math.sin(particle.pulse) * 0.3);
                        this.drawHeart(particle.x, particle.y, pulseSize);
                        break;
                        
                    case 'sparkles':
                        const sparkleOpacity = Math.sin(particle.sparklePhase) * 0.5 + 0.5;
                        this.ctx.globalAlpha *= sparkleOpacity;
                        this.drawSparkle(particle);
                        break;
                        
                    case 'matrix':
                        this.ctx.fillStyle = this.getParticleColor(particle, '#00ff00');
                        this.ctx.font = `${particle.size * 5}px monospace`;
                        this.ctx.fillText(particle.char, particle.x, particle.y);
                        break;
                        
                    case 'particles':
                        const particleAlpha = particle.life;
                        this.ctx.globalAlpha *= particleAlpha;
                        this.ctx.fillStyle = this.getParticleColor(particle, '#00ffff');
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'glitch':
                        const glitchAlpha = particle.life / particle.maxLife;
                        this.ctx.globalAlpha *= glitchAlpha;
                        this.ctx.fillStyle = this.getParticleColor(particle, '#ff00ff');
                        this.ctx.fillRect(particle.x, particle.y, particle.size * 3, particle.size);
                        break;
                        
                    case 'neon':
                        const neonGradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.glowSize
                        );
                        neonGradient.addColorStop(0, this.getParticleColor(particle, '#ff00ff'));
                        neonGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                        this.ctx.fillStyle = neonGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.glowSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'magic':
                        // ç¹ªè£½è»Œè·¡ï¼ˆæé«˜äº®åº¦èˆ‡å°ºå¯¸ï¼‰
                        particle.trail.forEach((t, i) => {
                            this.ctx.globalAlpha = Math.min(1, t.life * 0.8);
                            this.ctx.fillStyle = this.getParticleColor(particle, '#b266ff');
                            this.ctx.beginPath();
                            this.ctx.arc(t.x, t.y, particle.size * (t.life * 1.5 + 0.5), 0, Math.PI * 2);
                            this.ctx.fill();
                        });
                        
                        // ç¹ªè£½ä¸»ç²’å­
                        this.ctx.globalAlpha = Math.min(1, particle.opacity * 1.2);
                        this.ctx.fillStyle = this.getParticleColor(particle, '#ff89c6');
                        this.drawStar(particle.x, particle.y, 6, particle.size * 2.5, particle.size * 1.2);
                        break;
                        
                    case 'fairy':
                        const shimmerOpacity = Math.sin(particle.shimmer) * 0.3 + 0.9;
                        this.ctx.globalAlpha *= shimmerOpacity;
                        const fairyGradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 4
                        );
                        fairyGradient.addColorStop(0, this.getParticleColor(particle, 'rgba(255, 200, 220, 0.95)'));
                        fairyGradient.addColorStop(1, 'rgba(255, 200, 220, 0)');
                        this.ctx.fillStyle = fairyGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size * 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'portal':
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        const distance = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                        const radiusFade = Math.max(this.canvas.width, this.canvas.height) * 0.4; // è‡ªé©æ‡‰å®¹å™¨
                        const portalOpacity = 1 - (distance / radiusFade);
                        this.ctx.globalAlpha *= Math.max(0.2, Math.min(1, portalOpacity));
                        this.ctx.fillStyle = this.getParticleColor(particle, '#4e7bff');
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size * 1.2, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'runes':
                        this.drawRune(particle, index);
                        break;
                }
                
                this.ctx.restore();
            }
            
            drawLightning() {
                this.ctx.save();
                this.ctx.strokeStyle = this.getParticleColor({hue: 60}, 'rgba(255, 255, 255, 0.9)');
                this.ctx.lineWidth = Math.random() * 3 + 1;
                this.ctx.shadowColor = 'white';
                this.ctx.shadowBlur = 10;
                
                let x = Math.random() * this.canvas.width;
                let y = 0;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                
                while (y < this.canvas.height) {
                    x += (Math.random() - 0.5) * 50;
                    y += Math.random() * 30 + 20;
                    this.ctx.lineTo(x, y);
                }
                
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            drawSakuraPetal(particle) {
                this.ctx.translate(particle.x, particle.y);
                this.ctx.rotate(particle.angle);
                
                this.ctx.fillStyle = this.getParticleColor(particle, '#ffb6c1');
                this.ctx.beginPath();
                
                // ç¹ªè£½æ«»èŠ±èŠ±ç“£å½¢ç‹€
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const petalX = Math.cos(angle) * particle.size;
                    const petalY = Math.sin(angle) * particle.size * 0.6;
                    
                    if (i === 0) {
                        this.ctx.moveTo(petalX, petalY);
                    } else {
                        this.ctx.quadraticCurveTo(0, 0, petalX, petalY);
                    }
                }
                
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawButterfly(particle) {
                this.ctx.translate(particle.x, particle.y);
                
                const wingFlap = Math.sin(particle.wingPhase) * 0.3;
                
                // å·¦ç¿…è†€
                this.ctx.save();
                this.ctx.rotate(wingFlap);
                this.ctx.fillStyle = this.getParticleColor(particle, '#ff69b4');
                this.ctx.beginPath();
                this.ctx.ellipse(-particle.size, 0, particle.size, particle.size * 0.5, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // å³ç¿…è†€
                this.ctx.save();
                this.ctx.rotate(-wingFlap);
                this.ctx.fillStyle = this.getParticleColor(particle, '#ff69b4');
                this.ctx.beginPath();
                this.ctx.ellipse(particle.size, 0, particle.size, particle.size * 0.5, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // èº«é«”
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(-1, -particle.size, 2, particle.size * 2);
            }
            
            drawHeart(x, y, size) {
                this.ctx.fillStyle = this.getParticleColor({hue: 0}, '#ff1493');
                this.ctx.beginPath();
                this.ctx.moveTo(x, y + size / 4);
                this.ctx.quadraticCurveTo(x - size / 2, y - size / 4, x - size / 4, y);
                this.ctx.quadraticCurveTo(x, y + size / 4, x, y + size / 2);
                this.ctx.quadraticCurveTo(x, y + size / 4, x + size / 4, y);
                this.ctx.quadraticCurveTo(x + size / 2, y - size / 4, x, y + size / 4);
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawSparkle(particle) {
                const sparkleColor = this.getParticleColor(particle, '#ffd700');
                this.ctx.fillStyle = sparkleColor;
                this.ctx.strokeStyle = sparkleColor;
                this.ctx.lineWidth = 2;
                
                // ç¹ªè£½åå­—å½¢é–ƒçˆ
                this.ctx.beginPath();
                this.ctx.moveTo(particle.x - particle.size, particle.y);
                this.ctx.lineTo(particle.x + particle.size, particle.y);
                this.ctx.moveTo(particle.x, particle.y - particle.size);
                this.ctx.lineTo(particle.x, particle.y + particle.size);
                
                // ç¹ªè£½å°è§’ç·š
                this.ctx.moveTo(particle.x - particle.size * 0.7, particle.y - particle.size * 0.7);
                this.ctx.lineTo(particle.x + particle.size * 0.7, particle.y + particle.size * 0.7);
                this.ctx.moveTo(particle.x + particle.size * 0.7, particle.y - particle.size * 0.7);
                this.ctx.lineTo(particle.x - particle.size * 0.7, particle.y + particle.size * 0.7);
                
                this.ctx.stroke();
            }
            
            drawRune(particle, index) {
                this.ctx.translate(particle.x, particle.y);
                this.ctx.rotate(this.runeRotations[index] || 0);
                
                this.ctx.strokeStyle = this.getParticleColor(particle, '#b08cff');
                this.ctx.lineWidth = 2.5;
                this.ctx.shadowColor = '#b08cff';
                this.ctx.shadowBlur = 8;
                
                const runeSymbols = [
                    // ä¸åŒçš„ç¬¦æ–‡ç¬¦è™Ÿè·¯å¾‘
                    () => { // ä¸‰è§’å½¢
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -particle.size);
                        this.ctx.lineTo(-particle.size * 0.8, particle.size * 0.5);
                        this.ctx.lineTo(particle.size * 0.8, particle.size * 0.5);
                        this.ctx.closePath();
                        this.ctx.stroke();
                    },
                    () => { // åœ“å½¢å¸¶åå­—
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        this.ctx.moveTo(-particle.size, 0);
                        this.ctx.lineTo(particle.size, 0);
                        this.ctx.moveTo(0, -particle.size);
                        this.ctx.lineTo(0, particle.size);
                        this.ctx.stroke();
                    },
                    () => { // å…­é‚Šå½¢
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const x = Math.cos(angle) * particle.size;
                            const y = Math.sin(angle) * particle.size;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                ];
                
                const runeType = particle.runeType % runeSymbols.length;
                runeSymbols[runeType]();
            }
            
            drawStar(x, y, points, outer, inner) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.beginPath();
                
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i * Math.PI) / points;
                    const radius = i % 2 === 0 ? outer : inner;
                    const dx = Math.cos(angle) * radius;
                    const dy = Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        this.ctx.moveTo(dx, dy);
                    } else {
                        this.ctx.lineTo(dx, dy);
                    }
                }
                
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.restore();
            }
            
            animate() {
                this.time += 1;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.particles.forEach((particle, index) => {
                    this.updateParticle(particle, index);
                    this.drawParticle(particle, index);
                });
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            // ä¸‹è¼‰ GIFï¼ˆå¢å¼·ï¼šå½±ç‰‡é€å¹€å‰é€²ã€worker å¤±æ•—æ™‚å–®åŸ·è¡Œç·’å›é€€ï¼‰
            async downloadGif() {
                this.setButtonsState(true);
                this.showProgress('æ­£åœ¨ç”Ÿæˆ GIF å‹•ç•«...');
                
                const fps = parseInt(document.getElementById('fps').value);
                const duration = parseInt(document.getElementById('duration').value);
                const quality = parseFloat(document.getElementById('quality').value);
                const totalFrames = fps * duration;
                const maxFrames = Math.min(totalFrames, 180); // ä¸Šé™é¿å…è¶…é•·ç·¨ç¢¼å¡ä½
                
                const renderWithConfig = async (gifConfig) => {
                    return new Promise(async (resolve, reject) => {
                        try {
                            const gif = new GIF({
                                repeat: 0,
                                // transparent: 'rgba(0,0,0,0)', // é—œé–‰é€æ˜ä»¥æ¸›å°‘è¨ˆç®—é‡
                                // æé«˜å–æ¨£æ­¥é•·å¯æ¸›å°‘é‹ç®—ï¼ˆæ•¸å€¼è¶Šå¤§ç•«è³ªè¶Šä½ã€é€Ÿåº¦è¶Šå¿«ï¼‰
                                quality: Math.max(10, gifConfig.quality || 10),
                                dither: false,
                                ...gifConfig
                            });
                            
                            // æš«åœå³æ™‚å‹•ç•«ï¼Œé¿å…èˆ‡æ“·å–æµç¨‹äº’ç›¸å½±éŸ¿
                            if (this.animationId) {
                                cancelAnimationFrame(this.animationId);
                                this.animationId = null;
                            }
                            
                            // å–®ä¸€æš«å­˜ç•«å¸ƒä»¥é™ä½è¨˜æ†¶é«”å£“åŠ›
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                            tempCanvas.width = this.canvas.width;
                            tempCanvas.height = this.canvas.height;
                            
                            const renderFrameAsync = async (i) => {
                                // è‹¥ç‚ºå½±ç‰‡ï¼Œå°‡å½±ç‰‡æ™‚é–“æ¨é€²åˆ°å°æ‡‰å¹€
                                if (!this.isImage && this.mediaElement.readyState >= 2) {
                                    const targetTime = (i / fps) % (this.mediaElement.duration || 99999);
                                    if (Math.abs(this.mediaElement.currentTime - targetTime) > 0.01) {
                                        await new Promise((res) => {
                                            const onSeeked = () => {
                                                this.mediaElement.removeEventListener('seeked', onSeeked);
                                                res();
                                            };
                                            this.mediaElement.addEventListener('seeked', onSeeked, { once: true });
                                            this.mediaElement.currentTime = targetTime;
                                        });
                                    }
                                }
                                
                                // ç¹ªè£½åº•åœ–
                                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                                tempCtx.drawImage(this.mediaElement, 0, 0, tempCanvas.width, tempCanvas.height);
                                
                                // åœ¨è‡¨æ™‚ä¸Šä¸‹æ–‡ä¸Šæ¸²æŸ“ç‰¹æ•ˆ
                                this.particles.forEach((particle, index) => {
                                    this.updateParticle(particle, index);
                                    this.ctx = tempCtx;
                                    this.drawParticle(particle, index);
                                });
                                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                                
                                gif.addFrame(tempCanvas, { delay: Math.round(1000 / fps), copy: true, dispose: 2 });
                                
                                const progress = ((i + 1) / totalFrames) * 50;
                                this.updateProgress(progress, `ç”Ÿæˆå¹€ ${i + 1}/${totalFrames}`);
                            };
                            
                            // é€æ­¥éåŒæ­¥è™•ç†ï¼Œé¿å…é•·æ™‚é–“é˜»å¡
                            for (let i = 0; i < maxFrames; i++) {
                                await renderFrameAsync(i);
                                await new Promise(r => setTimeout(r, 0));
                            }
                            
                            // ç›£æ§ç·¨ç¢¼æ˜¯å¦å¡ä½
                            let lastProgress = 0;
                            let lastTick = Date.now();
                            const watchdog = setInterval(() => {
                                if (Date.now() - lastTick > 15000) { // 15 ç§’ç„¡é€²åº¦
                                    clearInterval(watchdog);
                                    try { if (typeof gif.abort === 'function') gif.abort(); } catch(_) {}
                                    reject(new Error('stalled'));
                                }
                            }, 3000);
                            
                            gif.on('progress', (p) => {
                                this.updateProgress(50 + p * 50, 'æ­£åœ¨ç·¨ç¢¼ GIF...');
                                if (p > lastProgress) {
                                    lastProgress = p;
                                    lastTick = Date.now();
                                }
                            });
                            
                            gif.on('finished', (blob) => {
                                try { clearInterval(watchdog); } catch(_) {}
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `effect_${this.effectType}_${Date.now()}.gif`;
                                a.click();
                                URL.revokeObjectURL(url);
                                resolve();
                            });
                            
                            gif.on('abort', () => reject(new Error('GIF ç·¨ç¢¼è¢«ä¸­æ­¢')));
                            gif.on('error', (err) => reject(err || new Error('GIF ç·¨ç¢¼ç™¼ç”ŸéŒ¯èª¤')));
                            
                            gif.render();
                        } catch (e) {
                            reject(e);
                        }
                    });
                };
                
                try {
                    // å…ˆå˜—è©¦ä½¿ç”¨ workersï¼ˆè¼ƒç©©å®šèˆ‡å¿«é€Ÿï¼‰
                    await renderWithConfig({
                        workers: 2,
                        quality: Math.round((1 - quality) * 20) + 8, // æé«˜æ•¸å€¼ä»¥åŠ é€Ÿ
                        width: this.canvas.width,
                        height: this.canvas.height,
                        workerScript: 'gif.worker.js'
                    });
                } catch (err) {
                    console.warn('Workers ç”Ÿæˆå¤±æ•—æˆ–å¡ä½ï¼Œæ”¹ç”¨å–®åŸ·è¡Œç·’ä½è² è¼‰æ¨¡å¼...', err);
                    try {
                        await renderWithConfig({
                            workers: 0,
                            quality: Math.round((1 - quality) * 20) + 12, // å†æé«˜ä»¥é™ä½è² æ“”
                            width: this.canvas.width,
                            height: this.canvas.height
                        });
                    } catch (err2) {
                        console.error('GIF generation failed:', err2);
                        alert('GIF ç”Ÿæˆå¤±æ•—ã€‚è«‹å˜—è©¦ã€Œä½è² è¼‰æ¨¡å¼ã€ï¼Œæˆ–é€²ä¸€æ­¥é™ä½æ™‚é•·/FPS/å“è³ª/å¼·åº¦');
                        this.hideProgress();
                        this.setButtonsState(false);
                        // åŒ¯å‡ºå¤±æ•—å¾Œæ¢å¾©å³æ™‚å‹•ç•«
                        if (!this.animationId) this.animate();
                        return;
                    }
                }
                
                this.hideProgress();
                this.setButtonsState(false);
                // åŒ¯å‡ºå®Œæˆå¾Œæ¢å¾©å³æ™‚å‹•ç•«
                if (!this.animationId) this.animate();
            }
            
            async downloadMp4() {
                this.setButtonsState(true);
                this.showProgress('æ­£åœ¨éŒ„è£½ä¸¦è½‰æª” MP4...');
                
                const fps = parseInt(document.getElementById('fps').value);
                const duration = parseInt(document.getElementById('duration').value);
                const quality = parseFloat(document.getElementById('quality').value);
                
                try {
                    const recordCanvas = document.createElement('canvas');
                    const recordCtx = recordCanvas.getContext('2d', { willReadFrequently: true });
                    recordCanvas.width = this.canvas.width;
                    recordCanvas.height = this.canvas.height;
                    
                    const stream = recordCanvas.captureStream(fps);
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 5000000 * quality
                    });
                    
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        try {
                            const webmBlob = new Blob(this.recordedChunks, {type: 'video/webm'});
                            this.showProgress('æ­£åœ¨è½‰æª”ç‚º MP4 (ç€è¦½å™¨ç«¯è½‰æª”)...');
                            const mp4Blob = await this.convertWebmToMp4(webmBlob);
                            const url = URL.createObjectURL(mp4Blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `effect_${this.effectType}_${Date.now()}.mp4`;
                            a.click();
                            URL.revokeObjectURL(url);
                        } catch (e) {
                            console.error('è½‰æª” MP4 å¤±æ•—ï¼Œæ”¹ä¸‹è¼‰ WebMï¼š', e);
                            // å›é€€ï¼šæä¾› WebM
                            const blob = new Blob(this.recordedChunks, {type: 'video/webm'});
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `effect_${this.effectType}_${Date.now()}.webm`;
                            a.click();
                            URL.revokeObjectURL(url);
                            alert('ç€è¦½å™¨ç«¯è½‰æª” MP4 å¤±æ•—ï¼Œå·²æ”¹ä¸‹è¼‰ WebMã€‚å¯ç”¨ ffmpeg æ¡Œé¢å·¥å…·è½‰æª”ã€‚');
                        } finally {
                            this.hideProgress();
                            this.setButtonsState(false);
                        }
                    };
                    
                    // é–‹å§‹éŒ„è£½
                    this.mediaRecorder.start();
                    
                    const totalFrames = fps * duration;
                    let frameIndex = 0;
                    
                    const renderFrame = () => {
                        if (frameIndex >= totalFrames) {
                            this.mediaRecorder.stop();
                            return;
                        }
                        
                        // ç¹ªè£½åº•åœ–
                        recordCtx.clearRect(0, 0, recordCanvas.width, recordCanvas.height);
                        if (this.isImage) {
                            recordCtx.drawImage(this.mediaElement, 0, 0, recordCanvas.width, recordCanvas.height);
                        } else {
                            recordCtx.drawImage(this.mediaElement, 0, 0, recordCanvas.width, recordCanvas.height);
                        }
                        
                        // åœ¨è‡¨æ™‚ä¸Šä¸‹æ–‡ä¸Šæ¸²æŸ“ç‰¹æ•ˆ
                        this.particles.forEach((particle, index) => {
                            this.updateParticle(particle, index);
                            this.ctx = recordCtx;
                            this.drawParticle(particle, index);
                        });
                        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                        
                        frameIndex++;
                        const progress = (frameIndex / totalFrames) * 100;
                        this.updateProgress(progress, `ç”Ÿæˆå¹€ ${frameIndex}/${totalFrames}`);
                        
                        // ä»¥å›ºå®šå¹€ç‡éè¿´
                        setTimeout(renderFrame, 1000 / fps);
                    };
                    
                    this.showProgress('æ­£åœ¨ç”Ÿæˆ MP4 å½±ç‰‡...');
                    renderFrame();
                } catch (error) {
                    console.error('MP4 generation failed:', error);
                    alert('MP4 ç”Ÿæˆå¤±æ•—ï¼Œè«‹é‡è©¦');
                    this.hideProgress();
                    this.setButtonsState(false);
                }
            }
            
            downloadImage() {
                try {
                    const outCanvas = document.createElement('canvas');
                    const outCtx = outCanvas.getContext('2d');
                    outCanvas.width = this.canvas.width;
                    outCanvas.height = this.canvas.height;
                    
                    // åº•åœ–
                    if (this.isImage) {
                        outCtx.drawImage(this.mediaElement, 0, 0, outCanvas.width, outCanvas.height);
                    } else {
                        outCtx.drawImage(this.mediaElement, 0, 0, outCanvas.width, outCanvas.height);
                    }
                    
                    // ç‰¹æ•ˆï¼ˆä»¥ç›®å‰ç•«é¢ç‚ºä¸»ï¼‰
                    outCtx.drawImage(this.canvas, 0, 0);
                    
                    const url = outCanvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `effect_${this.effectType}_${Date.now()}.png`;
                    a.click();
                } catch (error) {
                    console.error('Image download failed:', error);
                    alert('åœ–ç‰‡ä¸‹è¼‰å¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
            
            setButtonsState(disabled) {
                const ids = ['downloadGifBtn', 'downloadMp4Btn', 'downloadImageBtn'];
                ids.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = disabled;
                });
            }
            
            showProgress(text) {
                const bar = document.getElementById('progressBar');
                const fill = document.getElementById('progressFill');
                const txt = document.getElementById('progressText');
                if (bar && fill && txt) {
                    bar.style.display = 'block';
                    fill.style.width = '0%';
                    txt.textContent = text || '';
                }
            }
            
            updateProgress(percent, text) {
                const fill = document.getElementById('progressFill');
                const txt = document.getElementById('progressText');
                if (fill) fill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                if (txt && text !== undefined) txt.textContent = text;
            }
            
            hideProgress() {
                const bar = document.getElementById('progressBar');
                const txt = document.getElementById('progressText');
                if (bar) bar.style.display = 'none';
                if (txt) txt.textContent = '';
            }
        }
        
        // åˆå§‹åŒ–
        window.addEventListener('load', () => {
            try {
                window.__engine = new EnhancedEffectEngine();
            } catch (e) {
                console.error('åˆå§‹åŒ–å¤±æ•—:', e);
            }
        });
    </script>
</body>
</html>